{"/memo":{"title":"Memo","data":{"빼먹지-말아야-하는-내용들-메모#빼먹지 말아야 하는 내용들 메모":""}},"/memo/memo-v2-understanding-payment":{"title":"Memo V2 Understanding Payment","data":{"part2-ch0401#Part2. Ch04.01":"","선불충전-금액이란#선불충전 금액이란?":"홍길동이라는 회원이 패캠페이에 가입해서 20만원을 충전하는 절차는 아래와 같다.Step1. 계좌등록실제로 패캠페이에 20만원이라는 머니 를 충전하려면 계좌 라는 존재가 실제로 존재해야 한다. 이런 이유로 페이서비스 등록 시 연결할 계좌를 먼저 등록하는 절차를 거치게 된다.Step2. 계좌 → Fastcampus Pay 법인으로 20만원 이체20만원을 Fastcampus Pay 에 이체해야 한다.Step3. Fastcampus Pay 로 이체 완료되었다는 응답 수신Fastcampus Pay 로 이체 완료되었다는 응답을 수신받은 후 다음단계로 진행Step4. Fastcampus Pay 시스템 내의 홍길동의 잔고를 업데이트Fastcampus Pay 법인 계좌로 이체가 완료가 되었다는 응답을 받은 후 Fastcampus Pay 내의 홍길동의 잔고를 실질적으로 업데이트 수행. SQL 등을 통해 데이터를 업데이트머니 라는 것은 선불 충전 금액을 의미하며, 이 선불충전 금액을 충전하려면\n계좌가 필수적으로 패캠페이 내의 홍길동 회원에 대해서 등록되어 있어야 하며\n이렇게 연결된 계좌를 통해서 충전을 해야 하게 되는데,\n이 금액은 결국 패캠페이의 법인 계좌에 입금되어 있어야 하며, 이것을 패캠머니라고 불린다.\n이런 이유로 어딘가에 송금할 때에는 반드시 머니가 충전되어 있어야 한다.페이 서비스들이 충전 이벤트를 자주 하는 이유는 충전이 많이 되면, 페이 시스템 내의 현금이 늘어나고, 여기에 대해 이자가 생긴다거나 하는 부수적인 효과가 있다.","펌뱅킹이란-#펌뱅킹이란 ?":"기존 페이시스템들의 공통점\n항상 특이하게도 10000 원씩만 충전이 된다.\n결제시 10000원이 넘으면 정확한 금액으로 충전.\n11000원을 충전하려고 하면 정확하게 11000원이 충전\n8000원을 충전하려고 하면 불가능하고, 기본적으로 최소 10000원까지만 충전 가능\n페이 서비스마다 송금 메뉴를 관찰해보면 이체 가능한 은행 목록이 다르다.\n펌뱅킹 이란?\n은행의 기능을 시스템적으로 이용하기 위한 하나의 수단\n은행의 펌뱅킹 시스템 사용하는 회사는 펌뱅킹 기능을 사용 시 마다 은행에 수수료를 지불해야 함\n은행 간의 거래, 은행 계좌 끼리의 돈의 이동을 의미\n입/출금 이행 요청시에 항상 고정 금액 수수료를 지불하게 됨\n펌뱅킹 시스템은 페이서비스 법인과 은행사이에 펌뱅킹 서비스 이용 등록을 해야 이용 가능\n따라서 페이서비스가 계약을 맺은 은행의 펌뱅킹을 통해서만 송금이 가능하기에 송금메뉴에 이체 가능한 은행 목록이 다르게 나타나는 것\n10000원 보다 낮게 충전을 허용하면?\n10000원 보다 낮은 금액을 충전하게 되면 펌뱅킹시 금액 상관 없이 소모되는 기본적인 수수료 500원(예시)으로 인해 손해(적자)가 발생","part2-ch0402#Part2. Ch04.02":"","송금-기능-이해#송금 기능 이해":"패캠페이 회원 → 패캠페이 회원 으로의 송금\n서비스 로직, DB Transaction\n패캠페이 회원 → 패캠페이 비회원의 계좌로 송금\n은행 상태 체크 (은행 점검시간, 수신가능 상태 등등 주기적으로 체크)\n입/출금 금액 관리\n법인 계좌 컨트롤\n이외 기타 작업들\n패캠페이 회원 → 패캠페이 회원으로의 송금외부로 현금이 유출되지 않는다. 페이서비스 법인 계좌의 예치금은 그대로이고, Database 내에서 송금자의 송금액을 차감하고, 수금자의 잔고에 송금액을 더하면 된다. Database 내의 잔고 데이터만 변하며 외부로 예치금이 유출되지 않음\n패캠페이 회원 → 패캠페이 비회원의 계좌로 송금외부로 현금이 유출된다.페이서비스 법인 계좌의 예치금이 외부로 이체된다.","결제-기능-이해#결제 기능 이해":"\"결제\" 는 전표를 생성하는 과정이다.\n홍길동이 피자를 먹고 싶다\n미스터 피자는 패캠페이 가맹점으로 등록했다.\n홍길동이 패캠페이로 결제를 수행\n패캠페이 시스템은 미스터 피자 사장님에 대해 전표를 발급\n이때 패캠페이에서 미스터피자로의 실제 입금은 즉시 이뤄지지 않는다.\n일정 시간이 지난 후 패캠페이 정산 작업을 거친 후 미스터 피자 사장님께 입금이 일어난다.","정산-기능-이해#정산 기능 이해":"\"정산\"은 전표를 통해 돈을 +/- 작업을 통해 정리하는 작업이다.\n정산 주기 : 실제 사장님들의 매출금액이 계산되어 패캠페이에서 사장님께 입금되는 주기\n가맹점 사장님은 수수료를 내야 한다.\n패캠페이 입장에서는 정산 주기가 늦을 수록 좋다.\n패캠페이 계좌에 입금된 돈이 계좌에 오래 있을 수록 이자수익이 있기 때문\n정산 주기가 짧아질 수록 이자 수익이 줄어든다.","필요-기능-정의#필요 기능 정의":"회원 가입 정보 변경 기능\nMembership 서비스에 \"계좌연결\" 기능이 추가로 필요하다.\n송금 기능 (회원 → 회원, 회원 → 비회원 은행계좌)\n회원 간 잔액 이동 비즈니스로직\nbanking 모듈 (실제 외부 은행 관리 시스템)\n가맹점의 결제 기능 + 정산기능\n가맹점 관리 시스템 + 계좌 등록 필요\n결제 시스템\n정산 기능 (e.g. 크론잡)"}},"/":{"title":"Introduction","data":{}},"/memo/memo-v1":{"title":"Memo V1","data":{"memo#memo":"","1-membership-service-작업#1. membership-service 작업":"build.gradle.kts\ndependencies {\r\n\timplementation(project(\":fastcampus-common\"))\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-data-jpa\")\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-web\")\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-validation\")\r\n//\timplementation(\"org.axonframework:axon-configuration:${property(\"axonVersion\")}\")\r\n//\timplementation(\"org.axonframework:axon-spring-boot-starter:${property(\"axonVersion\")}\")\r\n\timplementation(\"org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0\")\r\n\r\n\tcompileOnly(\"org.projectlombok:lombok\")\r\n\truntimeOnly(\"com.h2database:h2\")\r\n\truntimeOnly(\"com.mysql:mysql-connector-j\")\r\n\tannotationProcessor(\"org.projectlombok:lombok\")\r\n\ttestImplementation(\"org.springframework.boot:spring-boot-starter-test\")\r\n}\n패키지 구조SpringBootApplication 소스코드 작성\npackage io.chagchagchag.ddd.fastcampus_v1.membership;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class MembershipServiceApplication {\r\n  public static void main(String[] args) {\r\n    SpringApplication.run(MembershipServiceApplication.class, args);\r\n  }\r\n}\nadapter/in.web 에 아래의 controller 를 두어서 테스트 해본다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.adapter.in.web;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class TestController {\r\n  @GetMapping(path = \"/test\")\r\n  public String getTest(){\r\n    return \"Hello, nice to meet you.\";\r\n  }\r\n}","part2-ch0302-jpa와-hexagonal-아키텍처를-활용한-고객-서비스-개발-1#Part2. Ch03.02. JPA와 Hexagonal 아키텍처를 활용한 고객 서비스 개발 1":"","domain-영역---membership-클래스를-작성#domain 영역 - Membership 클래스를 작성":"조금 더 클린아키텍처 적으로 접근함.Membership 이라는 클래스는 오염이 되면 안되는 도메인 클래스\n핵심도메인이며, 고객 정보를 다루기 때문에 오염이 되면 안되기 때문에 final 로 선언하고 생성자의 접근 래벨을 PRIVATE 로 선언\npackage io.chagchagchag.ddd.fastcampus_v1.membership.domain;\r\n\r\nimport lombok.AccessLevel;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Getter;\r\n\r\n@AllArgsConstructor(access = AccessLevel.PRIVATE)\r\npublic class Membership {\r\n  @Getter private final String membershipId;\r\n  @Getter private final String name;\r\n  @Getter private final String email;\r\n  @Getter private final String address;\r\n  @Getter private final boolean isValid;\r\n  @Getter private final boolean isCorp;\r\n}\n그리고 각각의 필드를 @Value 로 관리할 수 있도록 static class 들 만든다. @Value 는 불변객체를 위해서 선언하는 롬복의 어노테이션이다.@Value 에 대해서는 여기 를 확인하자. 현재 문서작업을 하고 있는 것이 아니라 실습을 하고 있는 중이어서 간단한 메모만 남겨두고 가는중. 몇 일 뒤에 문서화를 제대로 시작할 예정.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.domain;\r\n\r\nimport lombok.AccessLevel;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Getter;\r\nimport lombok.Value;\r\n\r\n@AllArgsConstructor(access = AccessLevel.PRIVATE)\r\npublic class Membership {\r\n  @Getter private final String membershipId;\r\n  @Getter private final String name;\r\n  @Getter private final String email;\r\n  @Getter private final String address;\r\n  @Getter private final boolean isValid;\r\n  @Getter private final String aggregateIdentifier;\r\n\r\n  public static Membership generateMember(\r\n      MembershipId membershipId, MembershipName membershipName,\r\n      MembershipEmail membershipEmail,\r\n      MembershipAddress membershipAddress,\r\n      MembershipIsValid membershipIsValid,\r\n      MembershipAggregateIdentifier membershipAggregateIdentifier\r\n  ){\r\n    return new Membership(\r\n        membershipId.membershipId,\r\n        membershipName.nameValue,\r\n        membershipEmail.emailValue,\r\n        membershipAddress.addressValue,\r\n        membershipIsValid.isValidValue,\r\n        membershipAggregateIdentifier.aggregateIdentifier\r\n    );\r\n  }\r\n\r\n  @Value\r\n  public static class MembershipId {\r\n    public MembershipId(String value){\r\n      this.membershipId = value;\r\n    }\r\n    String membershipId;\r\n  }\r\n\r\n  @Value\r\n  public static class MembershipName {\r\n    public MembershipName(String value) {\r\n      this.nameValue = value;\r\n    }\r\n\r\n    String nameValue;\r\n  }\r\n  @Value\r\n  public static class MembershipEmail {\r\n    public MembershipEmail(String value) {\r\n      this.emailValue = value;\r\n    }\r\n    String emailValue;\r\n  }\r\n\r\n  @Value\r\n  public static class MembershipAddress {\r\n    public MembershipAddress(String value) {\r\n      this.addressValue = value;\r\n    }\r\n    String addressValue;\r\n  }\r\n\r\n  @Value\r\n  public static class MembershipIsValid {\r\n    public MembershipIsValid(boolean value) {\r\n      this.isValidValue = value;\r\n    }\r\n    boolean isValidValue;\r\n  }\r\n\r\n  @Value\r\n  public static class MembershipAggregateIdentifier {\r\n    public MembershipAggregateIdentifier(String value) {\r\n      this.aggregateIdentifier = value;\r\n    }\r\n    String aggregateIdentifier;\r\n  }\r\n}","membership-entity-정의#Membership entity 정의":"package io.chagchagchag.ddd.fastcampus_v1.membership.adapter.out.persistence;\r\n\r\nimport jakarta.persistence.Entity;\r\nimport jakarta.persistence.GeneratedValue;\r\nimport jakarta.persistence.Id;\r\nimport jakarta.persistence.Table;\r\nimport lombok.AccessLevel;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Getter;\r\nimport lombok.NoArgsConstructor;\r\n\r\n@Getter\r\n@Entity\r\n@Table(name = \"membership\")\r\n@AllArgsConstructor\r\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\r\npublic class MembershipJpaEntity {\r\n  @Id @GeneratedValue\r\n  private Long membershipId;\r\n  private String name;\r\n  private String address;\r\n  private String email;\r\n\r\n  private boolean isValid;\r\n\r\n  private String aggregateIdentifier;\r\n\r\n  public MembershipJpaEntity(String name, String address, String email, boolean isValid, String aggregateIdentifier) {\r\n    this.name = name;\r\n    this.address = address;\r\n    this.email = email;\r\n    this.isValid = isValid;\r\n    this.aggregateIdentifier = aggregateIdentifier;\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return \"MembershipJpaEntity{\" +\r\n        \"membershipId=\" + membershipId +\r\n        \", name='\" + name + '\\'' +\r\n        \", address='\" + address + '\\'' +\r\n        \", email='\" + email + '\\'' +\r\n        \", isValid=\" + isValid +\r\n        \", aggregateIdentifier='\" + aggregateIdentifier + '\\'' +\r\n        '}';\r\n  }\r\n}","part2-ch0303-jpa-와-hexagonal-아키텍처를-활용한-고객서비스-개발-2#Part2. Ch03.03. JPA 와 Hexagonal 아키텍처를 활용한 고객서비스 개발 2":"","api-설계#api 설계":"Query 와 Command 로 분류해서 API 를 분류Query\n조회를 위한 용도\ne.g. find - membership (-by -membershipId)\nRequestParam : membershipId\nResponse : Membership (membershipId, name, addr, ...)\nCommand\n필요한 고객 정보를 받아서 신규 고객 멤버를 생성\nRequestParam : Membership(membershipId, name, addr, ...)\nResponse : 등록된 Membership 데이터와 Response Code (200, 201, 400, 500,..)","webadapter-선언#@WebAdapter 선언":"@WebAdapter 를 정의, WebAdapter 임을 알려주는 단순한 애노테이션이고, 실제로 다른 기능을 하지 않는 용도라고 함. 강사님도 스터디를 하면서 다른 외국자료를 보고 가져온 것이라고 이야기해주심.\npackage io.chagchagchag.ddd.fastcampus_v1.common;\r\n\r\nimport java.lang.annotation.Documented;\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\nimport org.springframework.core.annotation.AliasFor;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Target({ElementType.TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Component\r\npublic @interface WebAdapter {\r\n  @AliasFor(annotation = Component.class)\r\n  String value() default \"\";\r\n}\n그런데 이 WebAdapter 를 common 에 넣어두겠다고 하셨는데, 불안감이 엄습했다. 이거 왠지 나중에 common 모듈로 분리하겠는데? 하는 생각이 들어서 fastcampus-common 모듈을 새로 만들었다. 그리고 아래의 위치에 위의 코드를 위치시켜줬다. 실제 코드를 확인해보니 강사님도 common 모듈을 결국 멀티모듈로 분리해뒀다는 것을 확인했다.\nfastcampus-common 모듈의 build.gradle.kts 는 아래와 같이 작성해줬다.\ndependencies {\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-validation\")\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-web\")\r\n    // ... \r\n}\n그리고 fastcampus-common 모듈을 현재 모듈로 불러와야 한다. fastcampus-membership-service 모듈 내의 build.gradle.kts 파일에 아래와 같이 common 모듈을 include 하게끔 지정해준다.\n// ..\r\n\r\ndependencies {\r\n    // ...\r\n    \r\n\timplementation(project(\":fastcampus-common\"))\r\n    \r\n    // ...\r\n}","persistenceadapter-usecase#@PersistenceAdapter, @UseCase":"위에서 @WebAdapter 애노테이션을 추가하면서 @PersistenceAdapter, @UseCase 도 함께 추가해줌.@PersistenceAdapter, @UseCase 를 정의한다.\n@PersistenceAdapter : 영속성 계층에 Adapter 를 의미하는 논리적인 의미만을 담당하는 어노테이션\n@UseCase : Service 에 해당하는 계층을 표현하기 위한 논리적인 의미만을 담당하는 어노테이션\n@PersistenceAdapter\npackage io.chagchagchag.ddd.fastcampus_v1.common;\r\n\r\nimport java.lang.annotation.Documented;\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\nimport org.springframework.core.annotation.AliasFor;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Target({ElementType.TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Component\r\npublic @interface PersistenceAdapter {\r\n  @AliasFor(annotation = Component.class)\r\n  String value() default \"\";\r\n}\n@UseCase\npackage io.chagchagchag.ddd.fastcampus_v1.common;\r\n\r\nimport java.lang.annotation.Documented;\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\nimport org.springframework.core.annotation.AliasFor;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Target({ElementType.TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Component\r\npublic @interface UseCase {\r\n  @AliasFor(annotation = Component.class)\r\n  String value() default \"\";\r\n}","selfvalidating#SelfValidating":"SelfValidating 클래스 역시 추가해준다. common 패키지에 클래스를 추가하는 김에 SelfValidating 클래스 까지 추가해줬다.\npackage io.chagchagchag.ddd.fastcampus_v1.common;\r\n\r\nimport jakarta.validation.ConstraintViolation;\r\nimport jakarta.validation.ConstraintViolationException;\r\nimport jakarta.validation.Validation;\r\nimport jakarta.validation.Validator;\r\nimport jakarta.validation.ValidatorFactory;\r\nimport java.util.Set;\r\n\r\npublic abstract class SelfValidating<T> {\r\n  private Validator validator;\r\n\r\n  public SelfValidating() {\r\n    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\r\n    validator = factory.getValidator();\r\n  }\r\n\r\n  /**\r\n   * Evaluates all Bean Validations on the attributes of this\r\n   * instance.\r\n   */\r\n  protected void validateSelf() {\r\n    Set<ConstraintViolation<T>> violations = validator.validate((T) this);\r\n    if (!violations.isEmpty()) {\r\n      throw new ConstraintViolationException(violations);\r\n    }\r\n  }\r\n}","registermembershipcontroller#RegisterMembershipController":"Controller 의 코드는 아래와 같이 작성한다. adapter.in.web 패키지이다.처음에 작성했던 TestController 의 이름을 RegisterMembershipController 로 바꿔줬다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.adapter.in.web;\r\n\r\nimport io.chagchagchag.ddd.fastcampus_v1.common.WebAdapter;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.web.bind.annotation.PostMapping;\r\nimport org.springframework.web.bind.annotation.RequestBody;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@WebAdapter\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class RegisterMembershipController {\r\n  @PostMapping(path = \"/membership/register\")\r\n  public String register(@RequestBody RegisterMembershipRequest request){\r\n    // request 받기\r\n\r\n    // request → command 변환 작업 수행 \r\n      \r\n    // Use case 처리\r\n\r\n    return \"Hello, nice to meet you.\";\r\n  }\r\n}\nRegisterMembershipController 클래스의 역할은 아래와 같다.\nrequest 받기\nrequest → command 변환 작업 수행\nuse case 처리","registermembershipusecase#RegisterMembershipUseCase":"use case 는 실제 사용될 케이스를 의미하는데, 이렇게 실제 사용 예 라는 것을 interface 화 할 것이디. 위치는 application.port.in 패키지다.그리고 이 interface 를 implements 하는 것은 application.service 패키지에서 implements 하도록 할 것이다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.application.port.in;\r\n\r\npublic interface RegisterMembershipUseCase {\r\n  void registerMembership(RegisterMembershipCommand command);\r\n  void registerAxonMembership(RegisterMembershipCommand command);\r\n}\nRegisterMembershipCommand 는 아래에서 생성한다.","registermembershipcommand#RegisterMembershipCommand":"RegisterMembershipCommand 는 Controller 내에서 아래와 같이 변환되게끔 할 예정이다.\n@WebAdapter\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class RegisterMembershipController {\r\n  @PostMapping(path = \"/membership/register\")\r\n  public String register(@RequestBody RegisterMembershipRequest request){\r\n    // request 받기\r\n\r\n    // request → command 변환 작업 수행 \r\n      \r\n    // Use case 처리\r\n\r\n    return \"Hello, nice to meet you.\";\r\n  }\r\n}","사용자로부터-받은-request-를-command-로-변환해서-사용하는-이유#사용자로부터 받은 request 를 command 로 변환해서 사용하는 이유":"사용자로부터 받은 request 는 바로 사용하지 않는다. request 의 원본은 그대로 두고, Command 라고 하는 객체를 통해 Use case 처리를 한다. 이렇게 하는 이유는 강의에서는 추상화 개념을 이야기해줬지만, 내 생각은 이렇다. Request 의 경우 frontend 등의 요구사항에 의해 굉장히 자주 변하는 사항이며 validation 작업 역시 굉장히 많다. 그런데 이 request 를 use case 에서 그대로 받아서 처리한다면 use case 에서도 request 에 의존을 하게 된다. 이런 의존성을 끊기 위해서 Use Case 에서의 작업 처리는 Command 로 변환 후에 작업을 하게끔 하는 것이라고 이해를 했다.","registermembershipcommandjava#RegisterMembershipCommand.java":"RegisterMembershipCommand.java 의 내용은 아래와 같다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.application.port.in;\r\n\r\nimport jakarta.validation.constraints.NotNull;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.EqualsAndHashCode;\r\n\r\n@Builder\r\n@Data\r\n@EqualsAndHashCode(callSuper = false)\r\npublic class RegisterMembershipCommand {\r\n  @NotNull\r\n  private final String name;\r\n\r\n  @NotNull\r\n  private final String email;\r\n\r\n  @NotNull\r\n  private final String address;\r\n\r\n  @NotNull\r\n  private final boolean isValid;\r\n\r\n  public RegisterMembershipCommand(String name, String email, String address, boolean isValid) {\r\n    this.name = name;\r\n    this.email = email;\r\n    this.address = address;\r\n    this.isValid = isValid;\r\n  }\r\n}","registermembershipcontroller-구현-작업-1--request--command--usecase-호출#RegisterMembershipController 구현 작업 (1) : request → command & usecase 호출":"@WebAdapter\r\n@RequiredArgsConstructor\r\n@RestController\r\npublic class RegisterMembershipController {\r\n\r\n  private final RegisterMembershipUseCase registerMembershipUseCase;\r\n\r\n  @PostMapping(path = \"/membership/register\")\r\n  @Operation(summary = \"회원가입\", description = \"회원가입\")\r\n  public void register(@RequestBody RegisterMembershipRequest request){\r\n    // request 받기\r\n\r\n    // request → command 변환 작업 수행\r\n    RegisterMembershipCommand command = RegisterMembershipCommand.builder()\r\n        .name(request.getName())\r\n        .address(request.getAddress())\r\n        .email(request.getEmail())\r\n        .isValid(true)\r\n        .build();\r\n\r\n    // Use case 처리\r\n    registerMembershipUseCase.registerMembership(command);\r\n  }\r\n}\n참고 : 위의 코드까지는 registerMembershipUseCase.registerMembership(command) 메서드가 Membership 을 return 하고 있는데 뒤에서 axon framework 기반의 eda 구조로 전환하면, void 를 return 하는 메서드 구조로 변경한다.","service-정의--usecase-implements#Service 정의 : UseCase implements":"UseCase 구체타입을 implements 하기에 앞서서 정의할 동작들을 정리해보면 아래와 같다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.application.service;\r\n\r\n// ...\r\n\r\n@RequiredArgsConstructor\r\n@UseCase\r\n@Transactional\r\npublic class RegisterMembership implements RegisterMembershipUseCase {\r\n\r\n  @Override\r\n  public void registerMembership(RegisterMembershipCommand command) {\r\n    // command → DB\r\n\r\n    // 비즈니스 로직 → DB\r\n    // -- DB 에 접근하는 것은 external system 과의 통신.\r\n    // -- 따라서 port, adapter 를 통해서 통신\r\n\r\n  }\r\n\r\n  @Override\r\n  public void registerAxonMembership(RegisterMembershipCommand command) {\r\n\r\n  }\r\n}","applicationportoutregistermembershipport-정의#application.port.out.RegisterMembershipPort 정의":"package io.chagchagchag.ddd.fastcampus_v1.membership.application.port.out;\r\n\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.domain.Membership;\r\n\r\npublic interface RegisterMembershipPort {\r\n  void createMembership(\r\n      Membership.MembershipName membershipName\r\n      , Membership.MembershipEmail membershipEmail\r\n      , Membership.MembershipAddress membershipAddress\r\n      , Membership.MembershipIsValid membershipIsValid\r\n      , Membership.MembershipAggregateIdentifier membershipAggregateIdentifier\r\n  );\r\n}","adapterportoutpersistence--membershippersistenceadapter-정의#adapter.port.out.persistence : MembershipPersistenceAdapter 정의":"https://github.com/KimByeongKou/fastcampus-pay/blob/main/membership-service/src/main/java/com/fastcampuspay/membership/adapter/out/persistence/MembershipPersistenceAdapter.java\nPersistenceAdapter 의 역할은 실제 기술계층인 Spring Data Repository 컴포넌트의 인스턴스를 주입받고 이 인스턴스를 통해서 DB에 접근하는 실제 물리적인 기능을 수행한다. 이 기능을 역할로 분류한 것은 위에서 살펴봤던 application.port.out.RegisterMembershipPort interface 이다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.adapter.out.persistence;\r\n// ...\r\n@RequiredArgsConstructor\r\n@PersistenceAdapter\r\npublic class MembershipPersistenceAdapter implements RegisterMembershipPort{\r\n  private final SpringDataMembershipRepository membershipRepository;\r\n\r\n  @Override\r\n  public void createMembership(\r\n      MembershipName membershipName,\r\n      MembershipEmail membershipEmail,\r\n      MembershipAddress membershipAddress,\r\n      MembershipIsValid membershipIsValid,\r\n      MembershipAggregateIdentifier membershipAggregateIdentifier\r\n  ){\r\n    membershipRepository.save(\r\n        new MembershipJpaEntity(\r\n            membershipName.getNameValue(),\r\n            membershipEmail.getEmailValue(),\r\n            membershipAddress.getAddressValue(),\r\n            membershipIsValid.isValidValue(),\r\n            membershipAggregateIdentifier.getAggregateIdentifier()\r\n        )\r\n    );\r\n  }\r\n}","adapterportoutpersistence--springdatamembershiprepository-정의#adapter.port.out.persistence : SpringDataMembershipRepository 정의":"위에서 살펴봤던 SpringDataMembershipRepository 은 아래와 같다. 간단한 Jpa Repository 코드이다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.adapter.out.persistence;\r\n\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\npublic interface SpringDataMembershipRepository extends JpaRepository<MembershipJpaEntity, Long> {\r\n}","applicationserviceregistermembership-정의#application.service.RegisterMembership 정의":"결과적으로는 아래의 코드로 작성해줬다. RegisterMembershipPort 의 createMembership() 메서드를 호출함을 명시한다. RegisterMembershipPort 의 구현체는 MembershipPersistenceAdapter 이며, 실제 동작은 MembershipPersistenceAdapter 내의 createMembership() 메서드를 통해서 데이터베이스 저장 등의 동작을 수행하게 된다.\n@RequiredArgsConstructor\r\n@UseCase\r\n@Transactional\r\npublic class RegisterMembership implements RegisterMembershipUseCase {\r\n  private final RegisterMembershipPort registerMembershipPort;\r\n\r\n  @Override\r\n  public void registerMembership(RegisterMembershipCommand command) {\r\n    registerMembershipPort.createMembership(\r\n        new Membership.MembershipName(command.getName()),\r\n        new Membership.MembershipEmail(command.getEmail()),\r\n        new Membership.MembershipAddress(command.getAddress()),\r\n        new Membership.MembershipIsValid(command.isValid()),\r\n        new Membership.MembershipAggregateIdentifier(\"default\")\r\n    );\r\n  }\r\n\r\n  @Override\r\n  public void registerAxonMembership(RegisterMembershipCommand command) {\r\n\r\n  }\r\n}","adapteroutpersistencemembershipmapper#adapter.out.persistence.MembershipMapper":"https://github.com/KimByeongKou/fastcampus-pay/blob/main/membership-service/src/main/java/com/fastcampuspay/membership/adapter/out/persistence/MembershipMapper.java강의 초반이라 Database 에 데이터를 저장 직후에 Jpa Entity 를 바로 비즈니스 모델인 Membership 객체로 변환하는 mapToDomainEntity(Entity) 함수를 정의한다. 이 함수는 MembershipMapper 내에 정의하는데 참고로 이 코드는 나중에 가서는 Find 쿼리에서만 호출하게 된다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.adapter.out.persistence;\r\n\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.domain.Membership;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class MembershipMapper {\r\n  Membership mapToDomainEntity(\r\n      MembershipJpaEntity membership) {\r\n    System.out.println(membership.toString());\r\n    return Membership.generateMember(\r\n        new Membership.MembershipId(membership.getMembershipId()+\"\"),\r\n        new Membership.MembershipName(membership.getName()),\r\n        new Membership.MembershipEmail(membership.getEmail()),\r\n        new Membership.MembershipAddress(membership.getAddress()),\r\n        new Membership.MembershipIsValid(membership.isValid()),\r\n        new Membership.MembershipAggregateIdentifier(membership.getAggregateIdentifier())\r\n    );\r\n  }\r\n}","skip#skip":"이후의 mapper 로직 작성 부분 필기는 생략. 사소한 내용들이기에 강의자료를 보고 금방 따라갈 수 있다.","h2-설정#h2 설정":"dependencies {\r\n\truntimeOnly(\"com.h2database:h2\")\r\n    // ...\r\n}\napplication.yml\nspring:\r\n  h2:\r\n    console:\r\n      enabled: true\r\n      path: /h2-console\r\n  datasource:\r\n    driver-class-name: org.h2.Driver\r\n    url: jdbc:h2:mem:test\r\n    username: user\r\n    password:\r\n  jpa:\r\n    hibernate:\r\n      ddl-auto: create-drop\n구동해보고 정상 확인함","spring-doc-설정#spring doc 설정":"springfox 의 swagger 는 Spring 3.x 부터는 사용이 불가하다. 그래서 springdoc 를 사용하기로 함.springfox 와 다른 점은 Differentiation to Springfox project 에서 확인 가능함.Spring Doc 에 대한 자세한 설명은 https://springdoc.org/ 에서 확인 가능하다. https://springdoc.org 에서는 webflux 역시 지원하고 있으며 관련된 항목은 Spring-webflux/webmvc fn Functional Endpoint 에서 확인 가능하다.\n참고자료\nSpring Doc Official : springdoc.org\nSpringdoc-openapi Properties : Springdoc-openapi Properties\nspringfox 와 다른 점 :  Differentiation to Springfox project\nwebflux 의 함수형 엔드포인트 지원 방식 : Spring-webflux/webmvc fn Functional Endpoint","의존성-추가#의존성 추가":"3.x 이전 버전\nimplementation(\"org.springdoc:springdoc-openapi-ui:1.7.0\")\n3.x 이후 버전\nimplementation(\"org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0\")","applicationyml#application.yml":"springdoc:\r\n  default-consumes-media-type: application/json;charset=UTF-8\r\n  default-produces-media-type: application/json;charset=UTF-8\r\n  api-docs:\r\n    path: /api-docs\r\n    enabled: true # for dev\r\n  swagger-ui:\r\n    enabled: true # for dev\r\n    path: /swagger-ui.html\r\n    try-it-out-enabled: true\r\n  packages-to-scan: io.chagchagchag.ddd.fastcampus_v1.membership.adapter.in.web\r\n  cache:\r\n    disabled: true\r\n  version: v1","테스트#테스트":"위에서 springdoc.swagger-ui.path 에 설정한 경로인 http://localhost:8080/swagger-ui.html 로 접속해보면 아래와 같은 화면이 나타난다. 주소가 http://localhost:8080/swagger-ui/index.html 로 리다이렉팅 되었음을 확인 가능하다.","부가-설정#부가 설정":"Swagger 에 대해 별도의 설정을 해준다.application.yml 파일에는springdoc.version 항목을 추가해줬다. 커스텀한 설정이고, springdoc 에서 지원하는 항목은 아니다. 그냥 애플리케이션 레벨에서 필요한 key/value 를 @Value 애노테이션으로 읽어들일 항목을 추가해줬다.\n# ...\r\nspringdoc:\r\n  # ...\r\n  version: v1\r\n  # ...","springdocconfigjava#SpringDocConfig.java":"설정 코드는 아래와 같이 추가해줬다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.config;\r\n\r\nimport io.swagger.v3.oas.models.Components;\r\nimport io.swagger.v3.oas.models.OpenAPI;\r\nimport io.swagger.v3.oas.models.info.Contact;\r\nimport io.swagger.v3.oas.models.info.Info;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\npublic class SpringDocConfig {\r\n  @Bean\r\n  public OpenAPI openAPI(\r\n      @Value(\"${springdoc.version}\") String version\r\n  ){\r\n    Info info = new Info()\r\n        .title(\"패캠페이 v1\")\r\n        .version(version)\r\n        .description(\"패스트캠퍼스 간편결제 시스템 MSA 구축\")\r\n        .contact(new Contact().name(\"chagchagchag\").email(\"chagchagchag.dev@gmail.com\"));\r\n\r\n    return new OpenAPI().info(info).components(new Components());\r\n  }\r\n}","패키지-스캔-설정#패키지 스캔 설정":"# ...\r\nspringdoc:\r\n  # ...\r\n  packages-to-scan: io.chagchagchag.ddd.fastcampus_v1.membership.adapter.in.web","devprod-에-따라-swagger-disable-하기#dev,prod 에 따라 swagger disable 하기":"예를 들면 dev 프로필에서는 아래와 같이 설정하면 swagger 가 적용된다.\nspringdoc:\r\n  default-consumes-media-type: application/json;charset=UTF-8\r\n  default-produces-media-type: application/json;charset=UTF-8\r\n  api-docs:\r\n    path: /api-docs\r\n    enabled: true # for dev\r\n  swagger-ui:\r\n    enabled: true # for dev\r\n    path: /swagger-ui.html\r\n    try-it-out-enabled: true\r\n  packages-to-scan: io.chagchagchag.ddd.fastcampus_v1.membership.adapter.in.web\r\n  cache:\r\n    disabled: true\r\n  version: v1\nprod 프로필에서는 아래와 같이 설정하면 swagger 가 disabled 된다.\nspringdoc:\r\n  api-docs:\r\n    enabled: false\r\n  swagger-ui:\r\n    enabled: false\r\n  packages-to-scan: io.chagchagchag.ddd.fastcampus_v1.membership.adapter.in.web\r\n  version: v1","주요-애노테이션-들#주요 애노테이션 들":"spring fox 에서 사용하던 애노테이션들은 아래와 같이 변경됨\n@Api → @Tag\n@ApiIgnore 은 아래와 같이 spring docs 에서 표현 가능\n@Parameter(hidden) 또는\n@Operation(hidden = true) 또는\n@Hidden\n@ApiImplicitParam → @Parameter\n@ApiImplicitParams → @Parameters\n@ApiModel → @Schema\n@ApiModelProperty\n@ApiModelProperty(hidden = true) → @Schema(accessMode = READ_ONLY)\n@ApiOperation(value = \"aaa\", notes = \"bbb\") → @Operation(summary = \"aaa\", description = \"bbb\")\n@ApiParam → @Parameter\n@ApiResponse(code = 404, message = \"not found\") → @ApiResponse(responseCode = \"404\", description = \"bbb\")","swagger-로-api-테스트#swagger 로 api 테스트":"","데이터-확인-h2-console#데이터 확인 (h2-console)":"http://localhost:8080/h2-console 로 접속해서 확인\n아래와 같이 잘 insert 되었음을 확인 가능","멤버-조회-api-구현#멤버 조회 API 구현":"","findmembershipcontroller#FindMembershipController":"https://github.com/KimByeongKou/fastcampus-pay/blob/main/membership-service/src/main/java/com/fastcampuspay/membership/adapter/in/web/FindMembershipController.java조회를 위한 컨트롤러를 아래와 같이 작성\npackage io.chagchagchag.ddd.fastcampus_v1.membership.adapter.in.web;\r\n\r\nimport io.chagchagchag.ddd.fastcampus_v1.common.WebAdapter;\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.application.port.in.FindMembershipCommand;\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.application.port.in.FindMembershipUseCase;\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.domain.Membership;\r\nimport io.swagger.v3.oas.annotations.Operation;\r\nimport io.swagger.v3.oas.annotations.Parameter;\r\nimport io.swagger.v3.oas.annotations.Parameters;\r\nimport io.swagger.v3.oas.annotations.tags.Tag;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.PathVariable;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@Tag(name = \"member find\", description = \"회원조회\")\r\n@WebAdapter\r\n@RestController\r\n@RequiredArgsConstructor\r\npublic class FindMembershipController {\r\n  private final FindMembershipUseCase findMembershipUseCase;\r\n  @GetMapping(path = \"/membership/{membershipId}\")\r\n  @Parameters(value = {\r\n      @Parameter(name = \"membershipId\", description = \"회원 id\", example = \"1\")\r\n  })\r\n  @Operation(summary = \"회원조회\", description = \"회원조회\")\r\n  ResponseEntity<Membership> findMembershipByMemberId(@PathVariable(name = \"membershipId\") String membershipId){\r\n    FindMembershipCommand command = FindMembershipCommand.builder()\r\n        .membershipId(membershipId)\r\n        .build();\r\n    return ResponseEntity.ok(findMembershipUseCase.findMembership(command));\r\n  }\r\n\r\n  @GetMapping(path = \"/membership/axon/{membershipId}\")\r\n  ResponseEntity<Membership> findAxonMembershipByMemberId(@PathVariable String membershipId){\r\n    return null;\r\n  }\r\n}\n위의 코드에서 FindMembershipCommand 는 아래에서 작성 예정","findmembershipcommand#FindMembershipCommand":"강의에서는 FindMembershipRequest 를 작성 중이지만, 작성이 완료된 버전의 코드를 보면 FindMembershipCommand 를 사용하는 버전으로 변경됨. 따라서 FindMembershipCommand 정의를 옮겨보면 아래와 같다.application.port.in.FindMembershipCommand\npackage io.chagchagchag.ddd.fastcampus_v1.membership.application.port.in;\r\n\r\nimport io.chagchagchag.ddd.fastcampus_v1.common.SelfValidating;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.EqualsAndHashCode;\r\n\r\n@Data\r\n@Builder\r\n@EqualsAndHashCode\r\npublic class FindMembershipCommand extends SelfValidating<FindMembershipCommand> {\r\n  private final String membershipId;\r\n}","findmembershipusecase#FindMembershipUseCase":"그리고 이번에는 실제 데이터를 조회해오는 FindMembershipUseCase 를 작성해보면 아래와 같다.application.port.in.FindMembershipUseCase\npackage io.chagchagchag.ddd.fastcampus_v1.membership.application.port.in;\r\n\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.domain.Membership;\r\n\r\npublic interface FindMembershipUseCase {\r\n  Membership findMembership(FindMembershipCommand command);\r\n  Membership findAxonMembership(FindMembershipCommand command);\r\n}","applicationservicefindmembershipjava#application.service.FindMembership.java":"이제 위에서 작성했던 UseCase 인 FindMembershipUsecase 를 implements 한 service 인 FindMembership 클래스를 작성할 차례다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.application.service;\r\n\r\nimport io.chagchagchag.ddd.fastcampus_v1.common.UseCase;\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.application.port.in.FindMembershipCommand;\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.application.port.in.FindMembershipUseCase;\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.application.port.out.FindMembershipPort;\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.domain.Membership;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\n@RequiredArgsConstructor\r\n@UseCase\r\n@Transactional\r\npublic class FindMembership implements FindMembershipUseCase {\r\n  private final FindMembershipPort findMembershipPort;\r\n  @Override\r\n  public Membership findMembership(FindMembershipCommand command) {\r\n    return findMembershipPort.findMembership(new Membership.MembershipId(command.getMembershipId()));\r\n  }\r\n\r\n  @Override\r\n  public Membership findAxonMembership(FindMembershipCommand command) {\r\n    return null;\r\n  }\r\n}\nFindMembershipPort 를 정의해줘야 한다.","findmembershipportjava#FindMembershipPort.java":"FindMembershipPort 는 application.port.out 에 명시한 out 방향으로의 Port 명세이다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.application.port.out;\r\n\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.domain.Membership;\r\nimport io.chagchagchag.ddd.fastcampus_v1.membership.domain.Membership.MembershipId;\r\n\r\npublic interface FindMembershipPort {\r\n  Membership findMembership(MembershipId membershipId);\r\n}\n위와 같이 작성한 out 방향으로의 Port 명세는 실제 구현체를 만들어줘야 하는데, 이것은 adapter 에 정의한다.","membershpipersistenceadapterjava#MembershpiPersistenceAdapter.java":"위에서 작성한 MembershipPersistenceAdapter 에 FindMembershipPort 를 추가로 implements 해주고 findMembership() 메서드를 작성해준다. 추가해준 부분만 표시해보면 아래와 같다.\npackage io.chagchagchag.ddd.fastcampus_v1.membership.adapter.out.persistence;\r\n/ ...\r\n    \r\n@RequiredArgsConstructor\r\n@PersistenceAdapter\r\npublic class MembershipPersistenceAdapter implements RegisterMembershipPort, FindMembershipPort { // FindMembershipPort 를 추가로 implements 해줌\r\n  private final SpringDataMembershipRepository membershipRepository; \r\n  private final MembershipMapper membershipMapper; // 추가\r\n    \r\n  // ...\r\n  \r\n  @Override // implements\r\n  public Membership findMembership(MembershipId membershipId) {\r\n\t// Optional 처리\r\n    return membershipRepository.findById(Long.parseLong(membershipId.getMembershipId()))\r\n        .map(entity -> membershipMapper.mapToDomainEntity(entity))\r\n        .orElseThrow(() -> new IllegalArgumentException(\"회원이 존재하지 않습니다.\"));\r\n  }\r\n}","테스트-1#테스트":"서버 재기동 후 swagger 에서 멤버 추가, h2 Database 조회, memberId 를 기반으로 swagger 에서 멤버 조회를 해보면 정상적으로 잘 수행됨을 확인 가능하다."}}}